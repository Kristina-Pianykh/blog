<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Terminal</title>
    <link>//localhost:1313/</link>
    <description>Recent content on Terminal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 10 Aug 2024 07:07:07 +0100</lastBuildDate><atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Thesis Learnings, Part 4</title>
      <link>//localhost:1313/posts/thesis-learnings-part-4/</link>
      <pubDate>Sat, 10 Aug 2024 07:07:07 +0100</pubDate>
      
      <guid>//localhost:1313/posts/thesis-learnings-part-4/</guid>
      <description>&lt;h2 id=&#34;on-java-lsp-support-and-editor1&#34;&gt;On Java LSP support and editor&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;p&gt;A note on IDE. &lt;a href=&#34;https://github.com/letieu/btw.nvim?tab=readme-ov-file&#34;&gt;I use neovim btw&lt;/a&gt; but that was until God blessed me with Java. Is what you probably expect me to say. And indeed setting up a Java LSP for neovim turned out as difficult as they say. I abondoned my beloved code editor and asked daddy aka my employer for a premium license for IntelliJ. I spent a bit of time rewriting some of the most basic functionality from neovim config in Lua to Vim script to still benefit from Vim motions in the IntelliJ IDE. I have to admit the IDE made many things easier but after a while I still turned back to neovim. Buckled up and divided into the LSP setup once again. I ended up with &lt;a href=&#34;https://github.com/georgewfraser/java-language-server&#34;&gt;&lt;code&gt;java-language-server&lt;/code&gt;&lt;/a&gt; (as opposed to the more popular &lt;a href=&#34;https://github.com/mfussenegger/nvim-jdtls&#34;&gt;&lt;code&gt;jdtls&lt;/code&gt;&lt;/a&gt; but it gave me the most basic things I needed: code diagnostics and quick remedy strategies (hashtag &lt;code&gt;lsp_code_actions&lt;/code&gt;), signature help, autocomplete suggestions, etc. Although granted, there’re still many things I’m unhappy about (e.g. symbol signature and third-party code, more stable cross-project referencing) but this is most likely due to a skill issue.
The end line to this is that despite some LSP issues, I still found myself more productive writing Java in neovim as opposed to the fully featured IntelliJ IDE. Yet another tribute to the power of well ingrained development workflows and habits that neovim inspires.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;on-java-lsp-support-and-editor1&#34;&gt;On Java LSP support and editor&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;p&gt;A note on IDE. &lt;a href=&#34;https://github.com/letieu/btw.nvim?tab=readme-ov-file&#34;&gt;I use neovim btw&lt;/a&gt; but that was until God blessed me with Java. Is what you probably expect me to say. And indeed setting up a Java LSP for neovim turned out as difficult as they say. I abondoned my beloved code editor and asked daddy aka my employer for a premium license for IntelliJ. I spent a bit of time rewriting some of the most basic functionality from neovim config in Lua to Vim script to still benefit from Vim motions in the IntelliJ IDE. I have to admit the IDE made many things easier but after a while I still turned back to neovim. Buckled up and divided into the LSP setup once again. I ended up with &lt;a href=&#34;https://github.com/georgewfraser/java-language-server&#34;&gt;&lt;code&gt;java-language-server&lt;/code&gt;&lt;/a&gt; (as opposed to the more popular &lt;a href=&#34;https://github.com/mfussenegger/nvim-jdtls&#34;&gt;&lt;code&gt;jdtls&lt;/code&gt;&lt;/a&gt; but it gave me the most basic things I needed: code diagnostics and quick remedy strategies (hashtag &lt;code&gt;lsp_code_actions&lt;/code&gt;), signature help, autocomplete suggestions, etc. Although granted, there’re still many things I’m unhappy about (e.g. symbol signature and third-party code, more stable cross-project referencing) but this is most likely due to a skill issue.
The end line to this is that despite some LSP issues, I still found myself more productive writing Java in neovim as opposed to the fully featured IntelliJ IDE. Yet another tribute to the power of well ingrained development workflows and habits that neovim inspires.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;This post is part of the series on my 6-month ride through a project for my CS graduation thesis.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
    </item>
    
    <item>
      <title>Thesis Learnings, Part 3</title>
      <link>//localhost:1313/posts/thesis-learnings-part-3/</link>
      <pubDate>Wed, 10 Jul 2024 07:07:07 +0100</pubDate>
      
      <guid>//localhost:1313/posts/thesis-learnings-part-3/</guid>
      <description>&lt;h2 id=&#34;on-input-validation-and-error-handling1&#34;&gt;On input validation and error handling&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Always validate your inputs. And by that I mean ALWAYS. This will spare you hours of running simulations only to find out that something went wrong and changed the behaviour of the entire system&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm your expectation of the system behaviour. Especially in a non-deterministic aka asynchronous context. ESPECIALLY in a distributed setting with a high data transmission ratio. There’s no humanly possible way to prune gigabytes of log files to verify your assumptions.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;on-input-validation-and-error-handling1&#34;&gt;On input validation and error handling&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Always validate your inputs. And by that I mean ALWAYS. This will spare you hours of running simulations only to find out that something went wrong and changed the behaviour of the entire system&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confirm your expectation of the system behaviour. Especially in a non-deterministic aka asynchronous context. ESPECIALLY in a distributed setting with a high data transmission ratio. There’s no humanly possible way to prune gigabytes of log files to verify your assumptions.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For this purposes, I found the &lt;a href=&#34;https://github.com/bats-core/bats-core&#34;&gt;bats&lt;/a&gt; testing tool for bash quite useful. Instead of eyeballing the logs, toss in a few &lt;a href=&#34;https://github.com/BurntSushi/ripgrep&#34;&gt;&lt;code&gt;ripgrep&lt;/code&gt;&lt;/a&gt; commands and format the output with &lt;code&gt;awk&lt;/code&gt;/&lt;code&gt;tr&lt;/code&gt;. Running a simple bats script saved me a ton of time detecting faulty behaviour early in the development process. Because even the simplest thing like sending duplicated data in a system built with the &amp;ldquo;exactly-once&amp;rdquo; message delivery guarantee can quickly mess up your process.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Crash early. Even when you have your assumptions about the system behaviour verified and tested, poor error visibility and scope can kill a thread while keeping the program running. With a large enough timeout and numerous threads, this quickly becomes a major pain in the ass. That’s why the decisions on proper error handling should be made early in develolment (e.g. lift the error up to the parent thread or handle locally? crash the program early on a failure or continue with a warning log?). When using an object/function always pause for a sec to think what this object can hold/point to in case something goes wrong. What can this function return on a failure? And how do we want to communicate it? And just to top it all up, Java does not enforce error handling in a way that Rust or Go do (hashtag errors as values), a feature my heart desires as much as a strong typing system.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;This post is part of the series on my 6-month ride through a project for my CS graduation thesis.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
    </item>
    
    <item>
      <title>Thesis Learnings, Part 2</title>
      <link>//localhost:1313/posts/thesis-learnings-part-2/</link>
      <pubDate>Mon, 10 Jun 2024 07:07:07 +0100</pubDate>
      
      <guid>//localhost:1313/posts/thesis-learnings-part-2/</guid>
      <description>&lt;h2 id=&#34;on-abstraction-and-ugly-code1&#34;&gt;On abstraction and ugly code&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DO NOT ABSTRACT UNLESS ABSOLUTELY NECESSARY!&lt;/strong&gt; Yep, I said it. Abstractions are beautiful in theory and Java makes it so tempting to start with an abstraction and work your way down to specifics. Fight the urge to abstract early, you’ll thank me later.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This goes in hand with the above but I’ll make a separate point out of it. Do not try to be a smart-ass. Clean code, modularisation - out of the window. This is unimportant in the POC stage. Hack it out as fast as possible to get a working solution. I&amp;rsquo;d go even further than that. Make it your goal to make it as ugly as possible. Avoid early optimisation and getting stuck on splitting your code into functions 4 lines of code each (I&amp;rsquo;m sorry, Uncle Bob). Raw dawg 50 line-functions all the way, embrace code duplication. Embrace chaos. Only when it starts getting really uncomfortable for you (and by that I don’t mean your perfectionism), only then do some refactoring. Don’t let some abstract principle guide your hand. Make it dirty and functional because you learn so SO many things about the process.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;on-abstraction-and-ugly-code1&#34;&gt;On abstraction and ugly code&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DO NOT ABSTRACT UNLESS ABSOLUTELY NECESSARY!&lt;/strong&gt; Yep, I said it. Abstractions are beautiful in theory and Java makes it so tempting to start with an abstraction and work your way down to specifics. Fight the urge to abstract early, you’ll thank me later.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This goes in hand with the above but I’ll make a separate point out of it. Do not try to be a smart-ass. Clean code, modularisation - out of the window. This is unimportant in the POC stage. Hack it out as fast as possible to get a working solution. I&amp;rsquo;d go even further than that. Make it your goal to make it as ugly as possible. Avoid early optimisation and getting stuck on splitting your code into functions 4 lines of code each (I&amp;rsquo;m sorry, Uncle Bob). Raw dawg 50 line-functions all the way, embrace code duplication. Embrace chaos. Only when it starts getting really uncomfortable for you (and by that I don’t mean your perfectionism), only then do some refactoring. Don’t let some abstract principle guide your hand. Make it dirty and functional because you learn so SO many things about the process.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;rsquo;ll give an example. When I was working on a custom monitoring component for my Flink workload, I was presented with three different implementation ideas. Prettyfying from the start would have wasted my time since I had to hack out each of these approaches before arriving at a working solution.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;This post is part of the series on my 6-month ride through a project for my CS graduation thesis.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
    </item>
    
    <item>
      <title>Thesis Learnings, Part 1</title>
      <link>//localhost:1313/posts/thesis-learnings-part-1/</link>
      <pubDate>Fri, 10 May 2024 07:07:07 +0100</pubDate>
      
      <guid>//localhost:1313/posts/thesis-learnings-part-1/</guid>
      <description>&lt;h2 id=&#34;the-power-of-positive-mindset-even-if-its-java1&#34;&gt;The power of positive mindset (even if it’s java).&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;p&gt;It will get you a good head start on the most challenging part of solving a difficult problem with a language you &lt;del&gt;hate&lt;/del&gt; slightly dislike.
Having a positive mindset helped me push through the initial learning curve (especially the part with functional Java) and set me on the way of thinking to focus instead on the things that I do find enjoyable. For example, I hadn’t dealt so much with threads before and the way Java handles it makes it a less horrifying experience. But this applies to other things I had to find my way around in Java. Suddenly, the bloated world of alien Java modifiers (like &lt;code&gt;volitile&lt;/code&gt; and &lt;code&gt;synchronised&lt;/code&gt;) starts slowly to make sense. After building a a few simple TCP servers you feel slightly more confident and optimistic.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;the-power-of-positive-mindset-even-if-its-java1&#34;&gt;The power of positive mindset (even if it’s java).&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;
&lt;p&gt;It will get you a good head start on the most challenging part of solving a difficult problem with a language you &lt;del&gt;hate&lt;/del&gt; slightly dislike.
Having a positive mindset helped me push through the initial learning curve (especially the part with functional Java) and set me on the way of thinking to focus instead on the things that I do find enjoyable. For example, I hadn’t dealt so much with threads before and the way Java handles it makes it a less horrifying experience. But this applies to other things I had to find my way around in Java. Suddenly, the bloated world of alien Java modifiers (like &lt;code&gt;volitile&lt;/code&gt; and &lt;code&gt;synchronised&lt;/code&gt;) starts slowly to make sense. After building a a few simple TCP servers you feel slightly more confident and optimistic.&lt;/p&gt;
&lt;p&gt;Sooner or later (okay, rather sooner) you get the headache brought to you by the Java infamous object-oriented style. Keeping your scepticism at bay is sure not easy when you consistently find yourself in weird corners trying to do things &amp;ldquo;the idiomatic way&amp;rdquo;. Don&amp;rsquo;t get me wrong, I do believe that learning a language involves more than just learning its syntax (although it&amp;rsquo;s a topic for a separate post). And having come from procedural programming all the way, I still tried to keep an open mind. But when you find yourself wrapping your utils into a nominal class just because there is no other way in the OOP dictatorship you can&amp;rsquo;t help but wonder if you should side with a crowd of Java haters or it&amp;rsquo;s just a simple skill issue (spoiler: most likely the latter).&lt;/p&gt;
&lt;p&gt;Having said that (and hear me out!), the inheritance feature fits in perfectly in my use case where a data stream can hold different class objects and I branch off this stream further based on the properties of the class for each object. At the same time, all the (sub)classes share a massive amount of functionality (all objects represent messages) but each message can behave differently based on its class-unique properties and I want to be able to adjust the granularity of their representation based on whether I want to exploit their unique features or lump them all together as “messages”.&lt;/p&gt;
&lt;p&gt;All the while, what really took me a while to understand is polymorphism and interfaces. True, the concept is simple enough but I was hit with it all in the source code of the Apache Flink where I had a hard time understanding anonymous classes (note to myself: read up on it) and interface implementation. It is now that I know that anonymous classes are a single-instance implementations of an interface; that an interface is an absolute abstraction and you have to implement ALL of the listed methods as opposed to extending an abstract class. And while I was famuliar with the concepts of polymorphism and inheritance before, I was arguably overwhelmed when presented a bulky streaming library with all the Java ways of handling these OOP concepts.&lt;/p&gt;
&lt;p&gt;All complaints aside, this experience definitely challenged me in many ways but most imprtantly in the way I would usually approach a problem in the procedural programming paradigm. Tricking my brain not to be prejudiced and avoid pushing back against what has been widely criticized helped me stay curious and approach problems with stronger motivation than it would be otherwise. It helped me appreciate the strong sides of the Java world in practice and put into perspective the things I would otherwise do out of habit.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;This post is part of the series on my 6-month ride through a project for my CS graduation thesis.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
    </item>
    
    <item>
      <title>Why yet another platform?</title>
      <link>//localhost:1313/posts/why-another-platform/</link>
      <pubDate>Wed, 10 Apr 2024 07:07:07 +0100</pubDate>
      
      <guid>//localhost:1313/posts/why-another-platform/</guid>
      <description>&lt;p&gt;Ever since I was a child, I have always felt the need to document my thoughts and capture fleeting moments of my life. It started as a diary which served the purpose of retrospection (however much is imagineable in the life of a kid) which was of course naive but it helped me develop my writing and formulation skills. In high school, when I decided to go down the path of linguistics, I was required to pass a state examination on literature so there I was consuming the classics of literature and writing god knows how many literary analyses. I was compelled by the literary world and was blessed with a teacher who took my pursuits seriously and indulged me in lengthy discussions on the motives of literary heroes. As I moved into the depth of linguistic academia, the fiction literature was more and more replaced by scientific articles and empirical studies and the need to write migrated to personal notes on my IPhone. In both my linguistic and programming journey, I was genuinely passionate about the discoveries I was making and always tried to relate them to the modern world and my own experiences. I felt the need to share it.&lt;/p&gt;</description>
      <content>&lt;p&gt;Ever since I was a child, I have always felt the need to document my thoughts and capture fleeting moments of my life. It started as a diary which served the purpose of retrospection (however much is imagineable in the life of a kid) which was of course naive but it helped me develop my writing and formulation skills. In high school, when I decided to go down the path of linguistics, I was required to pass a state examination on literature so there I was consuming the classics of literature and writing god knows how many literary analyses. I was compelled by the literary world and was blessed with a teacher who took my pursuits seriously and indulged me in lengthy discussions on the motives of literary heroes. As I moved into the depth of linguistic academia, the fiction literature was more and more replaced by scientific articles and empirical studies and the need to write migrated to personal notes on my IPhone. In both my linguistic and programming journey, I was genuinely passionate about the discoveries I was making and always tried to relate them to the modern world and my own experiences. I felt the need to share it.&lt;/p&gt;
&lt;p&gt;And here comes the main problem: where? It might seem like an irrelevant question but over the years of my postings on Telegram, LinkedIn and Twitter, I realized that it DOES matter (at least to me). A social media platform shapes the narrative and brings with it certain expectations. While Telegram doesn&amp;rsquo;t seem like a place for thoughts on tech tools at all and is hard to easily share content in a professional setting, LinkedIn feels completely sterile and corporate. Although I&amp;rsquo;ve posted a few things there, I always felt like I had to contain myself not to god forbid to step too far from the grounds of ultimate corporate masturbation.&lt;/p&gt;
&lt;p&gt;Twitter in this regard appears to be a more suitable place for tech yapping and I appreciate it (although Twitter wars definitely take it too far), still it feels scandalous and attention-seeking.&lt;/p&gt;
&lt;p&gt;Thus yours truly with yet another &amp;lsquo;blogging&amp;rsquo; page. I don&amp;rsquo;t intend to promote it or shape an audience, instead I want to create a place free of expectations that would allow me to shape my thoughts in a way that wouldn&amp;rsquo;t imply a certain audience or content form.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
